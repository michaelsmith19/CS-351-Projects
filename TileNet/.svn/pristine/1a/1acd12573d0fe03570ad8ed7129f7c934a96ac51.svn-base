package com.putable.tilenet.client;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;

import com.putable.tilenet.Util.ChatFeature;
import com.putable.tilenet.Util.Common;
import com.putable.tilenet.Util.XMLParser;
import com.putable.tilenet.Util.XMLTags.LoggedIn;
import com.putable.tilenet.Util.XMLTags.LoginTag;
import com.putable.tilenet.Util.XMLTags.ServerTag;
import com.putable.tilenet.Util.XMLTags.SetTag;
import com.putable.tilenet.Util.XMLTags.XMLTag;
import com.putable.tilenet.Util.XMLTags.XMLTag.TagType;
import com.putable.tilenet.grid.GridImpl;
import com.putable.tilenet.matrixelement.Agent;
import com.putable.tilenet.matrixelement.MatrixElementBuilder;
import com.putable.tilenet.matrixelement.TileNetMatrixElementBuilder;
import com.putable.tilenet.matrixelement.Token;

public class TileNetClient {
	private final String clientHeader = "<?xml version='1.0' encoding='utf-8'?><!DOCTYPE client SYSTEM \"http://putable.com/TileNet/TileNet1.0.dtd\">";
	private static final int PORT = 44455;
	private JFrame jframe = new JFrame("Class Cast Exceptions TileNet");
	private JPanel chatPanel = new ChatFeature();
	private JPanel matrixPanel = new JPanel();
	private Agent agent;
	// private EmptyMatrix matrix;

	// Make a grid to represent all the Tokens in the current matrix.
	private GridImpl clientGrid = new GridImpl();

	private BlockingQueue<XMLTag> bq;

	public TileNetClient() {
		jframe.getContentPane().add(chatPanel, "South");
		// TODO add the matrix representation to gui
		// jframe.getContentPane().add(matrix.draw(), "North");
		// MatrixBuilder makeMatrices = new TileNetMatrixBuilder();
		// Matrix empty = makeMatrices.orderMatrix("EMPTY");
		// this.matrix = (EmptyMatrix) empty;
		jframe.pack();
	}

	/**
	 * Creates an InputDialog to get the IP address or hostName of a 'hopefully'
	 * running server.
	 * 
	 * @return A {@link String} that contains the hostName or IP address of the
	 *         server.
	 */
	private String getUserInput(String message) {
		return JOptionPane.showInputDialog(jframe,
				"Please provide your connecting information", message,
				JOptionPane.QUESTION_MESSAGE);
	}

	private void attemptConnection(String serverAddress) {
		MatrixElementBuilder makeElements = new TileNetMatrixElementBuilder();
		agent = (Agent) makeElements.orderElement("AGENT");
		agent.getConn().setDestination(serverAddress, PORT);
		// Try to connect to the port. If successful you will receive a valid
		// xml doctype and opening server tag.
		try {
			agent.getConn().connect();
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null, "Cannot connect to: "
					+ serverAddress);
			return;
		}
		getWriter();
	}

	private void startParsing() throws ParserConfigurationException,
			SAXException, IOException {
		bq = new LinkedBlockingQueue<XMLTag>();

		XMLParser xmlp = new XMLParser(bq);
		xmlp.setInputSource(agent.getConn().getIn2());

		Thread parseThread = new Thread(xmlp, "parseThread");
		parseThread.start();

	}

	private boolean connected = false;
	private boolean loggedIn = false;

	/**
	 * First we make sure we're logged in + connected, then we can start our set
	 * processing. at the moment it is the prized banana forloop but in our
	 * actual implementation it will become a switch statement to accomodate the
	 * remaining tags.
	 * 
	 * @param event
	 */
	private int isGridFinished = 0;

	private void processEvent(XMLTag event) {
		// System.out.println("THE NEXT EVENT IS : " + event);
		if (loggedIn && connected) {

			switch (event.getTagType()) {
			case SET: {
				SetTag sTag = (SetTag) event;
				Token tok = new Token(sTag);
				Point position = new Point(sTag.getX(), sTag.getY());
				clientGrid.addTokenToLayout(tok, position);
				isGridFinished++;
				break;
			}
			default:
				System.out.println("whaaa?");
			}

		} else if (connected) {
			if (event.getTagType() == TagType.LOGGEDIN)
				confirmLogin((LoggedIn) event);

			else
				System.out.println("expected Loggedin tag");

		}

		else
			tryToConnect(event);

	}

	private String ourObjid;

	/**
	 * this is what we do when we find a loggedintag, right now it prints to
	 * console but ideally that will be to our chat window, the objectID will be
	 * needed elsewhere in the client.
	 * 
	 * @param li
	 */
	private void confirmLogin(LoggedIn li) {
		ourObjid = li.getObjid();
		System.out.println(li.getMessage());
		loggedIn = true;
	}

	/**
	 * This is servertag preprocessing, can expand to work more error handling.
	 * Might go back and do something similar for confirmLogin
	 * 
	 * @param event
	 */
	private void tryToConnect(XMLTag event) {
		if (event.getTagType() == TagType.SERVER) {
			establishSession((ServerTag) event);
		} else
			System.out.println("WHAT R U DOING THAT IS NOT A SERVER TAG");
		// TODO error handling
	}

	/**
	 * Still need closed/busy cases and a dialogue box for username/password
	 * 
	 * @param st
	 */
	private void establishSession(ServerTag st) {
		if (st.getStatus().equals("open")) {
			connected = true;
			// TODO SHOUT REALLY LOUD, SET NAME AND WHATNOTNOT BASED ON INFO IN
			// SERVER TAG
			login();
		} else
			System.out.println("I'LL HANDLE THE REST I SWEAR IT");
	}

	/**
	 * sends a logintag to server as well as the opening header for a client.
	 */
	private void login() {
		// TODO GET USERNAME AND PARSSWORD FROM INPUT
		String userName = getUserInput("please provide a user name");
		String password = getUserInput("please provide a password");
		toServer.print(clientHeader);
		toServer.print(new LoginTag(userName, password));
	}

	private PrintWriter toServer;

	private void getWriter() {
		try {
			toServer = Common.getWriterFromSock(agent.getConn().getSock());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void run() throws ParserConfigurationException, SAXException,
			IOException, InterruptedException {
		String serverAddress = getUserInput("Please enter the IP address or host name");
		// Using the address from the input try to connect a socket.

		attemptConnection(serverAddress);

		// If successful make a parser
		startParsing();

		while (true) {
			XMLTag nextEvent = bq.take();
			processEvent(nextEvent);
			if (isGridFinished == 4)
				jframe.add(drawClientGrid());
		}
	}

	private JPanel drawClientGrid() {
		matrixPanel.setLayout(new GridLayout(2, 2));
		matrixPanel.setSize(new Dimension(400, 400));
		for (int x = 0; x < 2; x++) {
			for (int y = 0; y < 2; y++) {
				ImageIcon ic = new ImageIcon((new BufferedImage(200, 200,
						BufferedImage.TYPE_4BYTE_ABGR)));
				if (clientGrid.getLayout().get(new Point(x, y)) != null)
					ic = clientGrid.getLayout().get(new Point(x, y))
							.draw(200, 200);
				JLabel temp = new JLabel();
				// if (clientGrid.getLayout().get(new Point(x, y)) == null)
				// temp.setToolTipText(clientGrid.getLayout()
				// .get(new Point(x, y)).getSetTag().getText());
				// temp.setIcon(ic);
				temp.setIcon(ic);
				matrixPanel.add(temp);
			}
		}
		return matrixPanel;
	}

	// for (int i = 0; i <= 1; i++) {
	// for (int j = 0; j <= 1; j++) {
	// Point p = new Point(i, j);
	// if (clientGrid.getLayout().get(p) == null)
	// clientGrid.addTokenToLayout(new Token(), p);
	// ImageIcon icon = clientGrid.getLayout().get(p).draw(200, 200);
	// matrixPanel.getGraphics().
	// }
	// }
	// }

	public static void main(String[] args) throws ParserConfigurationException,
			SAXException, IOException, InterruptedException {

		TileNetClient client = new TileNetClient();
		client.jframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		client.jframe.setVisible(true);
		client.run();
	}

}

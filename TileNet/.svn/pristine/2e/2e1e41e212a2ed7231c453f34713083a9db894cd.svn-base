package com.putable.tilenet.Client;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.concurrent.Callable;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

import com.putable.tilenet.Util.Common;
import com.putable.tilenet.matrix.Matrix;
import com.putable.tilenet.matrix.MatrixElement;
import com.putable.tilenet.matrix.MatrixElementFactory.ElemType;

//TODO make this the base (abstract? interface?) class for all agent types.
public class Agent extends MatrixElement implements Callable<Void>{
	private final boolean isDebug = true;
	private final String clientAddress = "127.0.0.1";
	private final String nameOfAgent;
	private final Socket sock;
	private PrintWriter outgoing;
	private BufferedReader incoming;
	
	
	
	/**Creates a connection to a TileNet Server
	 * @param agentName
	 * 		String identification of this agent
	 * @param port
	 * 		what port to connect to
	 * @throws UnknownHostException
	 * 		When the IP can not be resolved
	 * @throws IOException
	 * 		Upon failing to open a {@link Socket} for any other reason except {@link UnknownHostException}
	 */
	public Agent(String agentName, int port) throws UnknownHostException, IOException {
		super(ElemType.AGENT);
		this.nameOfAgent = agentName;
		this.sock = new Socket(clientAddress, port);
		this.outgoing = Common.getWriterFromSock(sock);
		this.incoming = Common.getReaderFromSock(sock);
	}
	
	@Override
	public Void call() throws Exception {


		while(!sock.isClosed()){
			
			
			/*
			 * 
			 * DO STUFF WITH XML HERE
			 * 
			 * 				There should be a server login XML in the incoming stream
			 * 				that was requested on behalf of this client/agent via the
			 * 				Controller class associated with this connection. 
			 */

		}


		return null;
	}
	
	public void show(Matrix m){
		//Dummy parameters
		int DUMMYWIDTH = m.getTileRow();
		int DUMMYHEIGHT = m.getTileCol();
		
		
		JFrame frame = new JFrame(this.nameOfAgent + " View");
		JPanel matrix = new JPanel(new GridLayout(DUMMYWIDTH, DUMMYHEIGHT));
		for(int y = 0; y < DUMMYHEIGHT; y++) {
			for(int x = 0; x < DUMMYWIDTH; x++) {
				System.out.println(m.getLayout().get(new Point(y,x)).getText());
				ImageIcon ic = m.getLayout().get(new Point(y,x)).getDisplay(100);
				JLabel label = new JLabel();
				label.setIcon(ic);
				matrix.add(label);
			}
		}
		frame.add(matrix, BorderLayout.CENTER);
		//Make disconnectButton (ClientSide)
		JButton terminate = new JButton("Disconnect");
		terminate.setSize(50, 50);
		terminate.addActionListener(new ActionListener(){

			@Override
			public void actionPerformed(ActionEvent arg0) {
				try {
					disconnect();
				} catch (IOException e) {
					System.out.println("Error DISCONNECTING! Forcing Close");
					System.exit(-1);
				}				
			}
			
		});
		frame.add(terminate, BorderLayout.SOUTH);
		//Add more stuff as we like
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.pack();
		frame.setAlwaysOnTop(true);
		frame.setResizable(false);
		frame.setVisible(true);
		
	}
	
	public String getServerResponce() throws IOException{
		while(!incoming.ready()){ }
		String message = incoming.readLine();
		if (isDebug)
			System.out.println("Server -> Received by " + this + ": " + message);
		return message;		
	}
	
	public void sendMessage(String s){
		outgoing.println(s);
		if (isDebug)
			System.out.println(this + " -> Server: " + s);
	}	
	
	public void disconnect() throws IOException{
		if (isDebug)
			System.out.println(this + " Socket Closed " + (sock.isClosed() ? "AGAIN" : ""));
		incoming.close();
		outgoing.close();
		sock.close();
	}
	
	public String getName(){
		return this.nameOfAgent;
	}
	
	public String toString(){
		return getName() + "@" + getid();
		
	}

	@Override
	public ImageIcon getDisplay(int tileSize) {
		ImageIcon ic = new ImageIcon(makeBufferedImage());
		return ic;
		// TODO Actual representation of an Agent
	}
	
	private BufferedImage makeBufferedImage(){
		BufferedImage buffIm = new BufferedImage(10,10,BufferedImage.TYPE_4BYTE_ABGR);
		return buffIm;
		
	}
	

}

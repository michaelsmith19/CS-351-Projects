package com.putable.tilenet.Server;

import java.net.ServerSocket;
import java.util.concurrent.Callable;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import com.putable.tilenet.Controller.Controller;

/**The model for a TileNet implementation
 * @author ClassCastExceptions
 */
public class ServerModel implements Callable<Void>{
	private final int port;
	private final int maxConnections;
	private final ThreadPoolExecutor ex;
	
	/**A singular server constructor
	 * @param PORT
	 * 		The port to listen for connections on
	 * @param maxConnections
	 * 		Maximum number of connections to accept (to be refined later)
	 */
	public ServerModel(int PORT, int maxConnections){
		this.port = PORT;
		this.maxConnections = maxConnections;
		//Using this implementation instead of the factory method of Executors. We want to call activeCount() eventually
		this.ex = new ThreadPoolExecutor(maxConnections, maxConnections, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
	}

	@Override
	public Void call() throws Exception{
		//Check for address in use
		ServerSocket serverSocket = null;
		try {
			serverSocket = new ServerSocket(port);
		} catch (Exception e){
			System.out.println("Failed to get PORT:" + port);
			System.exit(0);
		}		
		
		int currentAgents = 0;
		//Accepts MAX_AGENTS incoming connections as of now
		while(currentAgents < maxConnections ){
			ex.submit(new Controller(this, currentAgents++, serverSocket.accept()));
			System.out.println("currentAgents:" + currentAgents);
		}
		
		//XXX As of now, will shutdown when MAX_AGENTS have connected
		//we need to add something to say when to shutdown
		ex.shutdown();
		while(!ex.isTerminated()) { }
		return null;
	}
	
}

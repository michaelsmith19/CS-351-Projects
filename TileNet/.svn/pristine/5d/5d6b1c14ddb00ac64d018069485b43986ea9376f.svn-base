package com.putable.tilenet.controller;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.util.concurrent.Callable;
import java.util.concurrent.LinkedBlockingQueue;

import com.putable.tilenet.Util.Common;
import com.putable.tilenet.Util.XMLParser;
import com.putable.tilenet.Util.XMLTags.XMLTag;
import com.putable.tilenet.connection.AgentConnection;
import com.putable.tilenet.connection.Connection;
import com.putable.tilenet.server.ServerModel;
import com.putable.tilenet.server.ServerModel.ServerDispatch;

/**
 * Runs in the ThreadPool of {@link ServerModel}. Each instance of
 * {@link Controller} represents a singular incoming connection to the Server.
 * 
 * @author ClassCastExceptions
 */
public class Controller implements Callable<Boolean> {
	private static final LinkedBlockingQueue<XMLTag> queue = new LinkedBlockingQueue<XMLTag>();
	private boolean cleanShutdown = false;	
	private final ServerDispatch dispatch;
	private final Connection conn;

	/**
	 * An individual instance of a client connected to the {@link ServerModel}
	 * 
	 * @param dispatch
	 *            The Model this handler will manipulate
	 * @param refrenceNumber
	 *            Unique agent number that identifies this agent
	 * @param sock
	 *            A half-duplex communication socket from Agent to
	 *            {@link ServerModel}
	 * @throws IOException
	 */
	public Controller(ServerDispatch dispatch, Socket sock) throws IOException {		
		this.dispatch = dispatch;
		this.conn = new AgentConnection();
		conn.makeFromOpenSocket(sock);
	}

	@Override
	public Boolean call() throws Exception {
		//Requests server information for a brand new Agent
		notifyServer();
		
		//Spawn a new thread. Because we have to
		XMLParser xmlp = new XMLParser(queue);
		xmlp.setInputSource(conn.getIn2());						
		Thread parse = new Thread(xmlp, this + " parser");
		parse.start();
		
		while(!conn.isClosed()){
			XMLTag tag = queue.take();
			dispatch.put(conn, tag);
		}
		
		// TODO Socket closed, was this an abrupt client disconnect?
		if (cleanShutdown) {
			return cleanShutdown;
		} else {
			dispatch.terminateConnection(this);
			return cleanShutdown;
		}
	}
	public Socket getSock(){
		return conn.getSock();
	}
	private void notifyServer() throws IOException {		
		dispatch.requestServerTag(this, conn);
	}
}
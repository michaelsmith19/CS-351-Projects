package com.putable.tilenet.server;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import com.putable.tilenet.Util.Common;
import com.putable.tilenet.controller.Controller;

/**The model for a TileNet implementation
 * @author ClassCastExceptions
 */
public class ServerModel implements Callable<Void>{
	private boolean isRunning;
	private final int port;
	private final int maxConnections;
	private final ExecutorService ex;
	private final ConcurrentMap<Socket, Controller> connections;
	
	//TODO these Strings need to be sent to the translator then sent
	//through the dtd validator, then again sent to the client so that
	//it may parse the information and set attributes that need to be set
	private final String version = "<server version=\"1.1\">";
	private final String group = "<server group = \"The Class Cast Exceptions\">";
	
	//This is supposed to be able to be changed, see ((c8.8.6.3)) for details
	private final String name = "<server name = \"TileNet World\">";
	
	/**A singular server constructor
	 * @param port
	 * 		The port to listen for connections on
	 * @param maxConnections
	 * 		Maximum number of concurrent connections to accept, after which the server will reply it is busy
	 */
	public ServerModel(int port, int maxConnections){
		this.isRunning = false;
		this.port = port;
		this.maxConnections = maxConnections;
		this.connections = new ConcurrentHashMap<Socket, Controller>();
		this.ex = Executors.newCachedThreadPool();
	}

	@Override
	public Void call() throws Exception{		
		//Give this Thread a name
		Thread.currentThread().setName("SERVERMODEL");		
		
		ServerSocket serverSocket = null;
		try{
			serverSocket = new ServerSocket(port);
			isRunning = true;			
		}catch (Exception e){
			System.err.println("Failed to bind port: " + port + "\n");
			throw e;
		}						
		
		//Runs until told to stop
		int agentNumber = 0;
		//This needs to be in the outgoing print method
		//-----> "<server status = \"open\">"
		while(isRunning){
			ex.submit(new Controller(this, ++agentNumber, serverSocket.accept()));
		}
		
		
		ex.shutdownNow();
		while(!ex.isTerminated()) { }
		serverSocket.close();
		return null;
	}

	/**Sends login information to a client, or a busy signal when it is full
	 * @param controller
	 * 		The connection attempting login
	 * @throws IOException
	 */
	public void sendLoginFor(Controller controller) throws IOException {
		PrintWriter outgoing = Common.getWriterFromSock(controller.getSock());
		if(connections.size() >= maxConnections){
			outgoing.println("<server status=\"busy\">");
		} else {
			if(connections.get(controller.getSock()) != null){
				//TODO replace with our exception class later for processing in our TileNetExceptionHandler
				throw new IllegalStateException("Multiple login attempt from: " + controller);
			}
			connections.put(controller.getSock(), controller);		
			outgoing.println("HERES SOME XML FOR LOGIN FROM SERVER");
			//I'm not sure if these go here
			outgoing.println(version);
			outgoing.println(group);
		}
	}

	/**Ask the client to terminate itself
	 * @param controller
	 * 		The connection handler for the client
	 * @throws IOException
	 * 		When writing to the socket
	 */
	public void sendTerminationXML(Controller controller) throws IOException {
		connections.remove(controller.getSock());
		PrintWriter outgoing = Common.getWriterFromSock(controller.getSock());
		outgoing.println("<server logged-out.message=\"you logged out\">");
		//XXX Should kill socket after??
	}
	
	/**Tells the Server to kill and remove the connection immediately
	 * @param controller
	 * 		The connection handler for the client
	 * @throws IOException
	 */
	public void terminateConnection(Controller controller) throws IOException {
		connections.remove(controller.getSock());
		controller.getSock().close();
	}
	
	/**Removes every connection, sets the server like it was just started
	 * @throws IOException
	 */
	public void terminateAllConnections() throws IOException{
		for(Socket sock: connections.keySet()){
			sock.close();
		}
		connections.clear();
	}
	
	public void terminateServer(){
		System.out.println("Server received shutdown request");
		this.isRunning = false;
	}
	
	public ConcurrentMap<Socket,Controller> getConnections(){
		return connections;
	}
	
	public boolean isRunning(){
		return isRunning;
	}	
}

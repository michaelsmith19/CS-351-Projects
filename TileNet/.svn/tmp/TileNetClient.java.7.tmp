package com.putable.tilenet.client;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.rmi.UnknownHostException;
import java.util.concurrent.BlockingQueue;

import javax.swing.Box;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
<<<<<<< .mine
=======
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;
>>>>>>> .r170

<<<<<<< .mine
=======
import com.putable.tilenet.Util.XMLParser;
import com.putable.tilenet.Util.XMLTags.ClientTag;
import com.putable.tilenet.Util.XMLTags.LoggedIn;
import com.putable.tilenet.Util.XMLTags.LoginTag;
import com.putable.tilenet.Util.XMLTags.ServerTag;
>>>>>>> .r170
import com.putable.tilenet.Util.XMLTags.XMLTag;
import com.putable.tilenet.connection.AgentConnection;
import com.putable.tilenet.connection.Connection;

@SuppressWarnings("serial")
public class TileNetClient extends JFrame {
	private final String clientHeader = "<?xml version='1.0' encoding='utf-8'?><!DOCTYPE client SYSTEM \"http://putable.com/TileNet/TileNet1.0.dtd\">";
	private Connection conn;
	private BlockingQueue<XMLTag> bq;
	private String port;
	private String hostname;
	private String name;

	public TileNetClient() {
		super("TileNet Client");
<<<<<<< .mine
		this.conn = new AgentConnection();
		makeJFrameStuff();
=======
		this.conn = new AgentConnection();
		bq = new LinkedBlockingQueue<XMLTag>();
		
		setPreferredSize(new Dimension(500,200));
		setLocationRelativeTo(null);
		
		add(makeConnectPanel(this), BorderLayout.CENTER);
				
		pack();
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		setVisible(true);
>>>>>>> .r170
	}
<<<<<<< .mine

	private void makeJFrameStuff() {
		setPreferredSize(new Dimension(800, 800));
		setLayout(new GridBagLayout());
=======
	
	private JPanel makeConnectPanel(final JFrame frame){		
		//This is a panel
		final JPanel panel = new JPanel();
		panel.setPreferredSize(new Dimension(300, 300));
		panel.setLayout(new GridBagLayout());
>>>>>>> .r170
		GridBagConstraints c = new GridBagConstraints();
<<<<<<< .mine

=======
		
		//That has these components
>>>>>>> .r170
		final JLabel port = new JLabel("None");
		final JLabel host = new JLabel("None");
		final JTextField portTxt = new JTextField("Please enter port", 30);
		final JTextField hostTxt = new JTextField("Please enter hostname", 30);
		final JButton connect = new JButton("CONNECT");
<<<<<<< .mine

=======
		portTxt.selectAll();
		hostTxt.selectAll();
		
>>>>>>> .r170
		//Who do these things
		portTxt.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				port.setText(portTxt.getText());
				setPort(portTxt.getText());
				connect.requestFocus();
			}
		});
		hostTxt.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				host.setText(hostTxt.getText());
				setHost(hostTxt.getText());
				portTxt.requestFocus();

			}
		});
		connect.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
<<<<<<< .mine
				if (isReadyToConnect()) {
					// This inner class expands into beginComm()
					// And we can't access the variables we need.
					// TODO fix control flow
					beginCommunication();
=======
				if(isReadyToConnect()){
					//Remove this panel from this panels frame, add new screen					
					frame.remove(panel);
					showLoginStatusPanel();
					frame.add(makeWelcomePanel(), BorderLayout.CENTER);
>>>>>>> .r170
				} else
					JOptionPane.showMessageDialog(null,
							"Please select a hostname and port",
							"Idiot Warning", JOptionPane.WARNING_MESSAGE);
			}
<<<<<<< .mine
		});

		portTxt.selectAll();
		hostTxt.selectAll();

=======
		});			
		
>>>>>>> .r170
		c.gridx = 0;
		c.gridy = 5;
		panel.add(portTxt, c);
		c.gridx = 0;
		c.gridy = 4;
		panel.add(hostTxt, c);
		c.gridx = 1;
		c.gridy = 5;
		panel.add(port, c);
		c.gridx = 1;
		c.gridy = 4;
		panel.add(host, c);
		c.gridx = 2;
		c.gridy = 4;
		panel.add(connect, c);	

<<<<<<< .mine
		pack();
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		setVisible(true);

=======
		return panel;		
>>>>>>> .r170
	}
<<<<<<< .mine

	private void setPort(String port) {
		this.port = port;
	}

	private void setHost(String host) {
		this.hostname = host;
	}

	private boolean isReadyToConnect() {
		return (port != null && hostname != null);
	}

	private void beginCommunication() {

		// revalidate();
=======
	
	
	
	private void showLoginStatusPanel(){		
		//These components are added to parent (main) frame
		JLabel status = new JLabel();
		status.setText("Not Authenticated");
		status.setBackground(Color.RED);
		status.setOpaque(true);
		add(status, BorderLayout.NORTH);
		revalidate();
>>>>>>> .r170
		repaint();

		//And changed when successful login happens
		if(connect()){
			status.setBackground(Color.GREEN);
			status.setText("Authenticated");
			revalidate();
			repaint();
		}		
	}
	
	private JPanel makeWelcomePanel(){
		//This is a panel
		final JPanel panel = new JPanel();		
		panel.setPreferredSize(new Dimension(300,300));
		panel.setLayout(new GridLayout());


		//Which has these components
		//TODO what our working frame will look like
		
		
		
		///-------DEBUG
		
		
		try {
			while (true)
				System.out.println(conn.getResponce());
		} catch (IllegalStateException e) {
			System.err.println("Ill state");
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO EXCEPTION CLIENTSIDE");
			e.printStackTrace();
		}
<<<<<<< .mine

		while (!conn.isClosed()) {

		}

	}

	//
	// private void attemptConnection(String serverAddress) {
	//
	//
	// // Try to connect to the port. If successful you will receive a valid
	// // xml doctype and opening server tag.
	// try {
	// conn.setDestination(serverAddress, PORT);
	// conn.connect();
	// } catch (Exception e) {
	// JOptionPane.showMessageDialog(null, "Cannot connect to: "
	// + serverAddress);
	// return;
	// }
	// getWriter();
	// }
	//
	// private void startParsing() throws ParserConfigurationException,
	// SAXException, IOException {
	// bq = new LinkedBlockingQueue<XMLTag>();
	//
	// XMLParser xmlp = new XMLParser(bq);
	// xmlp.setInputSource(conn.getIn2());
	//
	// Thread parseThread = new Thread(xmlp, "parseThread");
	// parseThread.start();
	//
	// }

	// private boolean connected = false;
	// private boolean loggedIn = false;

	/**
	 * First we make sure we're logged in + connected, then we can start our set
	 * processing. at the moment it is the prized banana forloop but in our
	 * actual implementation it will become a switch statement to accomodate the
	 * remaining tags.
	 * 
	 * @param event
	 */
	// private int isGridFinished = 0;
	//
	// private void processEvent(XMLTag event) {
	// // System.out.println("THE NEXT EVENT IS : " + event);
	// if (loggedIn && connected) {
	//
	// switch (event.getTagType()) {
	// case SET: {
	// this.matrix.receiveLatestTag((SetTag) event);
	// matrixPanel = matrix.draw();
	// jframe.repaint();
	//
	// /*
	// * if (isGridFinished == 0 || isGridFinished == 3)
	// * sTag.setBgColor(Color.black); else
	// * sTag.setBgColor(Color.gray); sTag.setFgColor(Color.white);
	// * Token tok = new Token(sTag); Point position = new
	// * Point(sTag.getX(), sTag.getY());
	// * clientGrid.addTokenToLayout(tok, position); isGridFinished++;
	// * break;
	// */
	// }
	// default:
	// System.out.println("whaaa?");
	// }
	//
	// } else if (connected) {
	// if (event.getTagType() == TagType.LOGGEDIN)
	// confirmLogin((LoggedIn) event);
	//
	// else
	// System.out.println("expected Loggedin tag");
	//
	// }
	//
	// else
	// tryToConnect(event);
	//
	// }
	//
	// private String ourObjid;

	/**
	 * this is what we do when we find a loggedintag, right now it prints to
	 * console but ideally that will be to our chat window, the objectID will be
	 * needed elsewhere in the client.
	 * 
	 * @param li
	 */
	// private void confirmLogin(LoggedIn li) {
	// ourObjid = li.getObjid();
	// System.out.println(li.getMessage());
	// loggedIn = true;
	// }

	/**
	 * This is servertag preprocessing, can expand to work more error handling.
	 * Might go back and do something similar for confirmLogin
	 * 
	 * @param event
	 */
	// private void tryToConnect(XMLTag event) {
	// if (event.getTagType() == TagType.SERVER) {
	// establishSession((ServerTag) event);
	// } else
	// System.out.println("WHAT R U DOING THAT IS NOT A SERVER TAG");
	// // TODO error handling
	// }

	/**
	 * Still need closed/busy cases and a dialogue box for username/password
	 * 
	 * @param st
	 */
	// private void establishSession(ServerTag st) {
	// if (st.getStatus().equals("open")) {
	// connected = true;
	// // TODO SHOUT REALLY LOUD, SET NAME AND WHATNOTNOT BASED ON INFO IN
	// // SERVER TAG
	// login();
	// } else
	// System.out.println("I'LL HANDLE THE REST I SWEAR IT");
	// }

	/**
	 * sends a logintag to server as well as the opening header for a client.
	 */
	// private void login() {
	// // TODO GET USERNAME AND PARSSWORD FROM INPUT
	// String userName = getUserInput("please provide a user name");
	// String password = getUserInput("please provide a password");
	// toServer.print(clientHeader);
	// toServer.print(new LoginTag(userName, password));
	// }
=======
		
		
		
		
		
		
		
		
		
		
		return panel;		
	}
	
	private boolean connect() {		
		//TODO handle specific exceptions, we can't have the GUI shit out on us
		boolean success = false;
		
		conn.setDestination(hostname, Integer.parseInt(port));
		try {
			//Establish actual TCP connection 
			conn.connect();
			
			//Start the parser thread
			XMLParser xmlp = new XMLParser(bq);
			xmlp.setInputSource(conn.getIn2());
			Thread parseThread = new Thread(xmlp, "parseThread");
			parseThread.start();
			
			//Expect to block until tag received, because it makes life simpler, and we are allowed to.	
			success = exchangeOpenTag()  & exchangeLoggedin();			
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("Server port was probably wrong");
			e.printStackTrace();
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SAXException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}		
		
		if(success)
			System.out.println("Debug. auth success");
		else
			System.out.println("Unable to login");
		return success;
	}
>>>>>>> .r170

<<<<<<< .mine
	// private PrintWriter toServer;
	//
	// private void getWriter() {
	// toServer = conn.getOut();
	// }
	//
	// public void run() throws ParserConfigurationException, SAXException,
	// IOException, InterruptedException {
	// String serverAddress =
	// getUserInput("Please enter the IP address or host name");
	// // Using the address from the input try to connect a socket.
	//
	// attemptConnection(serverAddress);
	//
	// // If successful make a parser
	// startParsing();
	//
	// while (true) {
	// XMLTag nextEvent = bq.take();
	// System.out.println(nextEvent);
	// processEvent(nextEvent);
	// }
	// }
=======
	private boolean exchangeOpenTag() throws InterruptedException {		
		boolean success = false;
		/*					Server
		 * 
		 *	((c8.8.4)) TAG PURPOSE: Announce a server's identifying information
	     *	and status to a (potential) client.
		 *
		 *	((c8.8.5)) TAG SEQUENCING: Is the document root tag for the server
	     *	side of the communication, so obviously the server tag open
	     *	must be the first thing sent after the XML and DTD headers,
	     *	and the server tag close must be the last thing sent before
	     *	the server output side of the connection is closed.
		 */
		XMLTag serverTag = bq.take();
		
		if(serverTag.getTagType() != TagType.SERVER)			
			System.err.println("Server is IN ERROR. Expected <server>, Received: " + serverTag);
		else if (((ServerTag)serverTag).getStatus().compareTo("open") == 0){
			/*					Client	
			 * 
			 *	((c8.1.4)) TAG PURPOSE: Announce a client's version to a server.
			 *
			 * 	((c8.1.5)) TAG SEQUENCING: client Is the document root tag for
			 *  the client side of the communication, so obviously the client open
			 *	must be the first thing sent after the XML and DTD headers,
			 *	and the client close must be the last thing sent before the
			 *	client output side of the connection is closed.
			 *
			 *	((c8.1.5.1)) As discussed in (cXXX), in the TileNet protocol
			 *	the server is required to 'speak first', so the client tag
			 *	(and the XML and DTD headers before it) are not to be sent
			 *	until the server open tag has been successfully parsed.
			 */
			conn.sendMessage(clientHeader + new ClientTag());
			success = true;
		}
		
		return success;		
	}

	private boolean exchangeLoggedin() throws InterruptedException{		
		JPanel panel = new JPanel();
		JTextField user = new JTextField(20);
		JTextField passwd = new JTextField(20);
		
		panel.add(new JLabel("Username"));
		panel.add(user);
		panel.add(Box.createHorizontalStrut(20));
		panel.add(new JLabel("Password"));
		panel.add(passwd);
		user.requestFocus();
		
		//TODO make it NOT use Option pane
		JOptionPane.showMessageDialog(null, panel, "Enter Username and password", JOptionPane.QUESTION_MESSAGE);
		user.requestFocus();
		
		/*						Login
		 * 
		 * 	((c8.6.4)) TAG PURPOSE: Authenticate a client to a server and
		 *	associate a particular user name and connection information
		 *	with a particular agent instance in the world.
		 *
		 *	((c8.6.5))  TAG SEQUENCING: Is sent at least once after the client tag  
         *	is opened.  After sending, client MUST wait for a logged-in
         *	tag from server before sending anything more.  If the
         *	returned logged-in tag indicates success, client MUST send
         *	no further login tags during that session.  If the returned
         *	logged-in tag indicates failure, client MAY choose to
         *	modify the user and/or password information (presumably in
         *	consultation with the client's user) and send another login
         *	tag.
         */
		conn.sendMessage(new LoginTag(user.getText(), passwd.getText()));

		/*					Logged-in
		 * 
		 *  ((c8.4.4)) TAG PURPOSE: Allow a server to let a client know whether
         *  the client's login attempt succeeded or failed.  In
         *  addition, if the login attempt succeeded, inform the client
         *  of the identity of the agent associated with the client.
         *  
		 *	((c8.4.5)) TAG SEQUENCING: A logged-in tag MUST be the first tag sent
         *  after a server open tag, sent upon receipt of a login tag
         *  from the client.  Multiple logged-in tags may be sent in a
         *  single session but only when all but the last one specific
         *  failure to login.
		 */		
		XMLTag tag = bq.take();

		if(tag.getTagType() != TagType.LOGGEDIN){
			//TODO loop somewhere
			System.err.println("Server is IN ERROR. Expected <logged-in>, Received: " + tag.toString());			
		}
		
		//TODO take this string and print it somewhere else
		LoggedIn loggedin = (LoggedIn) tag;
		System.out.println(loggedin.getMessage());			
		
		/*
		 * Optional: objid : agent object identifier
		 * 
		 * 	((c8.4.6.2.1)) PURPOSE: If omitted by the server, that indicates to the
         *  client that the login attempt failed.  If included by
         *  the server, that indicates to the client that the
         *  login attempt succeeded and provides the objid
         *  of the agent now associated with this client.
		 */
		if(loggedin.getObjid() != null)
			this.name = loggedin.getObjid();
		
				
		return (name != null) ? true : false;		
	}
	
>>>>>>> .r170

	private void setPort(String port) { this.port = port; }
	private void setHost(String host) { this.hostname = host; }
	private boolean isReadyToConnect() { return (port != null && hostname != null); }
}

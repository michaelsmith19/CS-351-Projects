package com.putable.tilenet.client;

import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;
import java.rmi.UnknownHostException;
import java.util.concurrent.BlockingQueue;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTextField;

import com.putable.tilenet.Util.XMLTags.XMLTag;
import com.putable.tilenet.connection.AgentConnection;
import com.putable.tilenet.connection.Connection;

@SuppressWarnings("serial")
public class TileNetClient extends JFrame {
	private final String clientHeader = "<?xml version='1.0' encoding='utf-8'?><!DOCTYPE client SYSTEM \"http://putable.com/TileNet/TileNet1.0.dtd\">";
	private Connection conn;
	private BlockingQueue<XMLTag> bq;
	private String port;
	private String hostname;

	public TileNetClient() {
		super("TileNet Client");
		this.conn = new AgentConnection();
		makeJFrameStuff();
	}

	private void makeJFrameStuff() {
		setPreferredSize(new Dimension(800, 800));
		setLayout(new GridBagLayout());
		GridBagConstraints c = new GridBagConstraints();

		final JLabel port = new JLabel("None");
		final JLabel host = new JLabel("None");
		final JTextField portTxt = new JTextField("Please enter port", 30);
		final JTextField hostTxt = new JTextField("Please enter hostname", 30);
		final JButton connect = new JButton("CONNECT");

		portTxt.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				port.setText(portTxt.getText());
				setPort(portTxt.getText());
				connect.requestFocus();
			}
		});
		hostTxt.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				host.setText(hostTxt.getText());
				setHost(hostTxt.getText());
				portTxt.requestFocus();

			}
		});
		connect.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				if (isReadyToConnect()) {
					// This inner class expands into beginComm()
					// And we can't access the variables we need.
					// TODO fix control flow
					beginCommunication();
				} else
					JOptionPane.showMessageDialog(null,
							"Please select a hostname and port",
							"Idiot Warning", JOptionPane.WARNING_MESSAGE);
			}
		});

		portTxt.selectAll();
		hostTxt.selectAll();

		c.gridx = 0;
		c.gridy = 5;
		add(portTxt, c);
		c.gridx = 0;
		c.gridy = 4;
		add(hostTxt, c);
		c.gridx = 1;
		c.gridy = 5;
		add(port, c);
		c.gridx = 1;
		c.gridy = 4;
		add(host, c);
		c.gridx = 2;
		c.gridy = 4;
		add(connect, c);

		pack();
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		setVisible(true);

	}

	private void setPort(String port) {
		this.port = port;
	}

	private void setHost(String host) {
		this.hostname = host;
	}

	private boolean isReadyToConnect() {
		return (port != null && hostname != null);
	}

	private void beginCommunication() {

		// revalidate();
		repaint();

		conn.setDestination(hostname, Integer.parseInt(port));
		try {
			conn.connect();
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("Connected");

		while (!conn.isClosed()) {

		}

	}

	//
	// private void attemptConnection(String serverAddress) {
	//
	//
	// // Try to connect to the port. If successful you will receive a valid
	// // xml doctype and opening server tag.
	// try {
	// conn.setDestination(serverAddress, PORT);
	// conn.connect();
	// } catch (Exception e) {
	// JOptionPane.showMessageDialog(null, "Cannot connect to: "
	// + serverAddress);
	// return;
	// }
	// getWriter();
	// }
	//
	// private void startParsing() throws ParserConfigurationException,
	// SAXException, IOException {
	// bq = new LinkedBlockingQueue<XMLTag>();
	//
	// XMLParser xmlp = new XMLParser(bq);
	// xmlp.setInputSource(conn.getIn2());
	//
	// Thread parseThread = new Thread(xmlp, "parseThread");
	// parseThread.start();
	//
	// }

	// private boolean connected = false;
	// private boolean loggedIn = false;

	/**
	 * First we make sure we're logged in + connected, then we can start our set
	 * processing. at the moment it is the prized banana forloop but in our
	 * actual implementation it will become a switch statement to accomodate the
	 * remaining tags.
	 * 
	 * @param event
	 */
	// private int isGridFinished = 0;
	//
	// private void processEvent(XMLTag event) {
	// // System.out.println("THE NEXT EVENT IS : " + event);
	// if (loggedIn && connected) {
	//
	// switch (event.getTagType()) {
	// case SET: {
	// this.matrix.receiveLatestTag((SetTag) event);
	// matrixPanel = matrix.draw();
	// jframe.repaint();
	//
	// /*
	// * if (isGridFinished == 0 || isGridFinished == 3)
	// * sTag.setBgColor(Color.black); else
	// * sTag.setBgColor(Color.gray); sTag.setFgColor(Color.white);
	// * Token tok = new Token(sTag); Point position = new
	// * Point(sTag.getX(), sTag.getY());
	// * clientGrid.addTokenToLayout(tok, position); isGridFinished++;
	// * break;
	// */
	// }
	// default:
	// System.out.println("whaaa?");
	// }
	//
	// } else if (connected) {
	// if (event.getTagType() == TagType.LOGGEDIN)
	// confirmLogin((LoggedIn) event);
	//
	// else
	// System.out.println("expected Loggedin tag");
	//
	// }
	//
	// else
	// tryToConnect(event);
	//
	// }
	//
	// private String ourObjid;

	/**
	 * this is what we do when we find a loggedintag, right now it prints to
	 * console but ideally that will be to our chat window, the objectID will be
	 * needed elsewhere in the client.
	 * 
	 * @param li
	 */
	// private void confirmLogin(LoggedIn li) {
	// ourObjid = li.getObjid();
	// System.out.println(li.getMessage());
	// loggedIn = true;
	// }

	/**
	 * This is servertag preprocessing, can expand to work more error handling.
	 * Might go back and do something similar for confirmLogin
	 * 
	 * @param event
	 */
	// private void tryToConnect(XMLTag event) {
	// if (event.getTagType() == TagType.SERVER) {
	// establishSession((ServerTag) event);
	// } else
	// System.out.println("WHAT R U DOING THAT IS NOT A SERVER TAG");
	// // TODO error handling
	// }

	/**
	 * Still need closed/busy cases and a dialogue box for username/password
	 * 
	 * @param st
	 */
	// private void establishSession(ServerTag st) {
	// if (st.getStatus().equals("open")) {
	// connected = true;
	// // TODO SHOUT REALLY LOUD, SET NAME AND WHATNOTNOT BASED ON INFO IN
	// // SERVER TAG
	// login();
	// } else
	// System.out.println("I'LL HANDLE THE REST I SWEAR IT");
	// }

	/**
	 * sends a logintag to server as well as the opening header for a client.
	 */
	// private void login() {
	// // TODO GET USERNAME AND PARSSWORD FROM INPUT
	// String userName = getUserInput("please provide a user name");
	// String password = getUserInput("please provide a password");
	// toServer.print(clientHeader);
	// toServer.print(new LoginTag(userName, password));
	// }

	// private PrintWriter toServer;
	//
	// private void getWriter() {
	// toServer = conn.getOut();
	// }
	//
	// public void run() throws ParserConfigurationException, SAXException,
	// IOException, InterruptedException {
	// String serverAddress =
	// getUserInput("Please enter the IP address or host name");
	// // Using the address from the input try to connect a socket.
	//
	// attemptConnection(serverAddress);
	//
	// // If successful make a parser
	// startParsing();
	//
	// while (true) {
	// XMLTag nextEvent = bq.take();
	// System.out.println(nextEvent);
	// processEvent(nextEvent);
	// }
	// }

}
